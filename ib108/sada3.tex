\documentclass[12pt]{article}
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{enumerate}
%\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{algorithm}
%\usepackage{tikz}


\pagestyle{plain}

\topmargin -5mm
\headsep 0mm
\headheight 3mm
\textheight 235mm
\textwidth 165mm
\oddsidemargin 0mm
\evensidemargin 0mm
\footskip 10mm

\newcommand{\eps}{\varepsilon}
\newcommand{\coL}{co\mbox{$-$}L}
\newcommand{\move}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\var}[1]{\textit{#1}}
\newcommand{\uv}[1]{\quotedblbase #1\textquotedblleft}
\newcommand{\ceil}[2]{\left\lceil\frac{#1}{#2}\right\rceil}
\newcommand{\floor}[2]{\left\lfloor\frac{#1}{#2}\right\rfloor}

\renewcommand{\O}{\mathcal{O}}

\newcommand{\zadani}[2]{
{\large
\noindent {\bf IB108 \hfill{} Sada #1, Příklad #2 \\[-4mm]}
\noindent\hrule
\vspace{2mm}
\noindent Vypracovali:\hfill{}Tomáš Krajča (255676), Martin Milata (256615)
\vspace{3mm}
\hrule
\bigskip\bigskip}
}


\begin{document}

\zadani{3}{1}

\clearpage
\zadani{3}{2}

\noindent
K řešení problému využijeme algoritmus prohledávání grafu do šířky.

\noindent
Graf $G$ je neorientovaný, s jednotkovou délkou hran. Tedy nejkratší cesta do všech vrcholů, které
jsou dosažitelné z kořene $s$ po jedné hraně, má délku $1$. Zároveň žádná jiná
cesta délky $1$ z kořene do těchto vrcholů nevede (zřejmě každá jiná cesta musí
obsahovat alespoň $2$ hrany). Dále můžeme pozorovat, že máme-li všechny vrcholy
$V_d$ s
minimální délkou $d$ z kořene $s$, pak jejich následníci (vrcholy spojené s nimi
jednou hranou, zatím nezpracované) mají minimální délku z kořene $d+1$. Kdyby
tomu
tak nebylo, tak by musela existovat cesta s délkou $<d$ do nějakého
vrcholu z $V_d$, popřípadě by následník musel být již zpracovaný.\\
Algoritmus \textsc{BFS} postupně dává do fronty všechny vrcholy, které jsou
dosažitelné z $s$ po jedné hraně, dále pak po dvou hranách, \dots Pokud tedy
spočítáme, kolikrát se nějaký vrchol vyskytuje ve frontě po iteraci $i$,
zjistíme, kolik minimálních cest délky $i$ do něj vede z $s$. Všechny
vrcholy ve frontě pak označíme jako zpracované, víme, že dále bychom našli delší
cesty do těchto vrcholů z $s$.

\noindent
Modifikovaný \textsc{BFS} pak vypadá takto:
\begin{algorithm}
\textsc{CountSSSP}$(s, V, E)$
\begin{algorithmic}[1]
\STATE $T \la$ tabulka velikosti $|V| \times 1$, $T[v]$ představuje počet
nejkratších cest z $s$ do $v$, inicializuj hodnoty tabulky na $0$ (nedosažitelné
vrcholy z $s$).
\STATE $Queue \la$ inicializuj frontu
\STATE $Queue.enqueue(s)$;
\WHILE {$not~Queue.empty()$}
\STATE $Count = Queue.size()$
\STATE Označ každý uzel ve frontě $Queue$ za navštívený
\WHILE {$Count > 0$}
\STATE $Node \la Queue.dequeue()$; $Count--$; $T[Node]++$;
\FORALL {nenavštívené uzly $u$ dosažitelné z uzlu $Node$ po jedné hraně}
\STATE $Queue.enqueu(u)$;
\ENDFOR
\ENDWHILE
\ENDWHILE
\RETURN $T$
\end{algorithmic}
\end{algorithm}

\noindent
Vnější \textit{WHILE} cyklus na řádku $4$ se provede nejvýše $|V|$ krát -- v
každém průchodu cyklem označíme alespoň jeden vrchol za navštívený. Vnitřní
\textit{WHILE} cyklus na řádku $7$ se provede nejvýše $|V|$ krát -- ve frontě
mohou být nejvýše všechny uzly. \textit{FOR} cyklus na řádku $9$ se provede
nejvýše $|V|$ krát -- pro všechny uzly. Tedy algoritmus skončí.

\noindent
Podrobnějším zkoumáním zjistíme, že složitost \textsc{CountSSSP} je
$\O\left(\sum_{i\in V} T[i]\right)$. Pro každý vrchol ve frontě se příkaz
$T[Node]++$ na řádku $8$ provede právě jedenkrát. Vrcholy se do fronty přidávají
pouze v nejvnitřnějším cyklu na řádku $10$ (samozřejmě jeden vrchol se přidá i
na řádku $3$). Tedy cena algoritmu je ohraničena maximálním počtem všech
minimálních cest z vrcholu $s$ do jednotlivých vrcholů grafu $G$. Do kteréhokoli
vrcholu grafu $G$ může vést nanejvýš tolik cest, jaký má stupeň. Vrchol má stupeň
nejvýše $|V|$, vrcholů je $|V|$, tedy maximální počet cest (ne nutně
minimálních) je $|V|^2$. Zřejmě neexistuje neorientovaný graf, který obsahuje
více než $|V|^2$ hran. Složitost algoritmu je tedy $\O(|H|)$.
\hfill$\square$

\clearpage
\zadani{3}{3}

\clearpage
\zadani{3}{4}

\noindent
Změnu ohodnocení hrany můžeme rozdělit na čtyři případy podle toho, zda je daná hrana součástí
minimální kostry v původním grafu a zda-li se její cena zvýšila nebo snížila.  Snadno nahlédneme, že
zvýší-li se cena hrany, která není součástí minimální kostry, minimální kostra se nezmění. Stejně
tak se nezmění kostra v případě, že se sníží cena hrany, která do kostry patří.

Pokud se zvýšila cena hrany ležící v původní kostře, odstraníme ji. Tím nám vzniknou dva stromy,
které jsou na svých vrcholech minimální
(pokud by nebyly minimální, byl by to spor s minimalitou původní kostry). Novou kostru
vytvoříme přidáním nejlevnější hrany, která oba vzniklé stromy opět spojí do jednoho (argument
korektnosti je stejný jako u Kruskalova algoritmu).

Podobně, pokud se snížila cena hrany neležící v původní kostře, do kostry ji přidáme. Tím vznikne graf
s právě jedním cyklem (pokud by vzniklo více cyklů, znamenalo by to, že před přidáním hrany už tam nějaký
cyklus byl, a že se tedy nejednalo o strom). Z tohoto cyklu poté odebereme hranu s nejvyšší cenou. Tento
postup je korektní, protože pokud bychom odstranili celý cyklus, získáme les stromů, které jsou
minimální na svých vrcholech.
Ty poté spojujeme postupným přidáním hran na cyklu (kdybychom museli přidat hranu která leží mimo
tento cyklus, dostali bychom spor s minimalitou původní kostry), které přidáme všechny kromě té nejdražší
-- tu tedy stačí odstranit.

Nechť $V$ je množina vrcholů, $E$ množina hran, $E'$ původní minimální kostra, $e=(u,v)$ hrana, která
se změnila, $w$ původní ohodnocení (cena) hrany a $w'$ nové ohodnocení hrany $e$.

\begin{algorithm}
\textsc{UpdateMST}$(V, E, E', e, w, w')$
\begin{algorithmic}[1]
\IF{$e \in E' \wedge w' < w$}
	\RETURN $(V,E')$
\ELSIF{$e \in E' \wedge w' > w$}
	\STATE $E' \la E' \smallsetminus \{e\}$
	\STATE Z vrcholu $u$ spusť na grafu $(V,E')$ \textsc{Dfs}, které všechny dosažené vrcholy označí $1$.
	\STATE Z vrcholu $v$ spusť na grafu $(V,E')$ \textsc{Dfs}, které všechny dosažené vrcholy označí $2$.
	\STATE Projdi všechny hrany takové, že jejich vrcholy jsou označeny různými čísly a vyber z~nich hranu $f$ s nejmenší cenou.
	\RETURN $(V,E' \cup \{f\})$
\ELSIF{$e \not\in E' \wedge w' < w$}
	\STATE $E' \la E' \cup \{e\}$
	\STATE Pomocí \textsc{Dfs} z vrcholu $u$ najdi v $(V,E')$ cyklus, hrany na něm ulož do množiny $C$.
	\STATE Nechť $f$ je hrana z $C$ s nejvyšší cenou.
	\RETURN $(V,E' \smallsetminus \{f\})$
\ELSIF{$e \not\in E' \wedge w' > w$}
	\RETURN $(V,E')$
\ENDIF
\end{algorithmic}
\end{algorithm}

\clearpage
\zadani{3}{4}
\noindent
Algoritmus realizuje výše uvedený postup. Prohledávání do hloubky trvá $\O(|E|)$, stejně tak procházení množin hran
(pokud jsou v nějaké rozumné datové struktuře, například pokud je graf reprezentován maticí sousednosti). Složitost
algoritmu je tedy $\O(|E|)$. Konvergence algoritmu vyplývá z konvergence podprogramů a absence
cyklů.

\end{document}
